[{"content":"Getting Started with Hugo Hugo is a static site generator (SSG). Simply put, an SSG prepares everything needed to display a website. In contrast, dynamically assembled websites obtain their assets only after they get accessed. An SSG thus minimizes the computational demand on the server, which allows providers, such as GitHub Pages and others1, to host your static sites for free. More importantly, SSGs emanate a philosophy of simplicity-by-design stemming from a number of limitations. Being constraint forces content creators to focus on the content itself and minimizes the distractions of layout and design. SSGs are thus especially suited for blogs, landing pages, documentation and portfolio sites.\nThe following is based on Ryan Schachte\u0026rsquo;s excellent video2 and similar tutorials (see links below).\nInstall Hugo On MacOS install Hugo from the command line using the Homebrew package manager.\nbrew install hugo On Debian Linux install Hugo with:\nsudo apt-get install hugo More installation instructions can be found here.\nSetting Up Two Repositories We will use GitHub Pages to host our static site for free. GitHub Pages are easily set up by creating a new public repository named username.github.io, where username is your GitHub username. If you were do save a simple HTML page as index.html in such a repo, you\u0026rsquo;d be able to view it at https://username.github.io.\nHowever, we\u0026rsquo;ll be slightly more considerate than dumping all of Hugo\u0026rsquo;s configuration code, templates, themes and markdown content into the GitHub repository. After all, to display the website correctly only the static site assets that Hugo compiles are needed. We are going to track all the rest in a separate repository called \u0026ldquo;blog\u0026rdquo;.\nSo please head over to GitHub and create two repositories:\n username.github.io: A public repository for the static site assets. blog (can have a different name): A private repository for Hugo containing configurations, themes, and unpublished posts.  Setting up Hugo Once we\u0026rsquo;ve created two repositories, we\u0026rsquo;ll clone them on our local system (git clone git@github.com:username/blog.git) and enter the \u0026ldquo;blog\u0026rdquo; repository (cd blog).\nHere we create the scaffolding for our website. In this case Hugo will create a new directory hugo-blog that contains all the Hugo assets.\nhugo new site hugo-blog Adding a Theme Enter the hugo-blog/themes directory and clone your preferred Hugo theme. For example, Hugo Bear Blog from Jan Raasch. Click on the \u0026ldquo;Download\u0026rdquo; button, copy the repository URL, and clone the theme into your themes/ folder using the submodule action. The submodule action avoids problems arising from nested cloning3.\n# Option 1: Original theme repo git submodule add https://github.com/janraasch/hugo-bearblog.git themes/hugo-bearblog Alternatively, you can first fork the theme directory by going to GitHub and clicking \u0026lsquo;Fork\u0026rsquo;. This has the advantage of being able to push changes to your fork of the themes directory later on.\nDon\u0026rsquo;t forget to add the fork as a submodule instead of the original repo. Replace username and hugo-theme with the respective values.\n# Option 2: Forked theme repo git submodule add https://github.com/username/hugo-theme.git themes/hugo-theme Then we add the theme\u0026rsquo;s name to the config.toml in blog\u0026rsquo;s base directory, e.g. hugo-blog/. The file might look like this:\nbaseURL = \u0026#39;https://username.github.io/\u0026#39; languageCode = \u0026#39;en-us\u0026#39; title = \u0026#39;My Blog Title\u0026#39; theme = \u0026#39;hugo-bearblog\u0026#39; The values of baseURL and theme obviously depend on your choice of host and theme.\nAdding the static site content repo as a submodule As mentioned above, we are decided to create a separate repository for the compiled static site content. In essence, we will let the username.github.io repository only track Hugo\u0026rsquo;s public/ output directory and nothing else. This way the commit history will purely reflect content updates. Plus, we can track any unpublished content in a private repo hidden from public view. The downside is that we have to remember to update both repositories.\nRun the following command from within the blog\u0026rsquo;s base directory (e.g. hugo-blog/) to link your public GitHub Pages repo to the public/ directory of your private blog repo. (If you receive an \u0026lsquo;already exists\u0026rsquo; error you might have to remove the public/ directory or its contents first.)\ngit submodule add -b main https://github.com/username/username.github.io.git public Building the site To perform the site build, run the following commands\n# create static assets in the \u0026#39;public/\u0026#39; directory hugo # commit the changes to the public submodule repository cd public git add . git commit -m \u0026#34;initial build\u0026#34; # commit references to submodule changes cd .. git add . git commit -m \u0026#34;initial build - update submodule references\u0026#34; # push both the source project and the submodule to remote git push -u origin master --recurse-submodules=on-demand Remember these command, you\u0026rsquo;ll have to repeat them for most changes to the site.\nThis concludes the basic Hugo setup. In the following we\u0026rsquo;ll go through posting, theme customization, adding images, and analytics. Let\u0026rsquo;s create our first post.\nCreating a Post Hugo posts are created in Markdown. The limited formatting options force authors to focus on the content. In general, it\u0026rsquo;s good advice not to try to change the formatting beyond what markdown offers. The theme\u0026rsquo;s template and CSS files provide better options while ensuring that the layout stays consistent across the site.\nTo create a new post, run:\nhugo new blog/mypost.md This will create a markdown file in the content/ directory, e.g. content/blog/mypost.md. Depending on your theme, you might have to substitute blog/ with post/ or posts/. Consult your theme\u0026rsquo;s documentation.\nOpen the freshly created post with your favorite editor. Hugo posts start with a preamble, the key: value pairs between the lines (---). The preamble sets various variables that Hugo will use to compile the site. Depending on the theme, you can add cover images, tags, and category labels. The draft status and publication date affect whether a post is published. You can add content below the preamble, like so.\n--- title: \u0026#34;My First Post\u0026#34; date: 2020-01-01T12:15:00+01:00 draft: true --- # Introduction  Some **bold** text and a [link](example.com). Now fire up the Hugo server locally in \u0026lsquo;draft\u0026rsquo; mode and open the respective URL with your browser, e.g. http://localhost:1313.\nhugo server -D If you\u0026rsquo;re new to Hugo, check out a particular theme\u0026rsquo;s example content. Not every theme will display posts the way you might expect. If you get stuck, start with the theme\u0026rsquo;s configuration files (config.toml) and content directories. The Bearblog example site  is a good start if you decided to use this theme.\nDrafts and Future Posts Note that the server doesn\u0026rsquo;t show blog posts with draft status by default. You can either set draft: true in the markdown file\u0026rsquo;s preamble or run the hugo server in draft mode. Besides draft status there are two more conditions that might prevent a post from being published, i.e. posts with a publication date in the future and posts with an expiry date4.\n# compile posts with draft status hugo server -D # compile posts with a future publication date hugo server -F Publishing To publish your site, run Hugo excluding drafts and future posts and push the changes to the remote repositories as described above.\nTracking Visitors Hugo and various themes make it easy to add analytics. Start by creating a new account or sign in with an existing Google account at https://analytics.google.com/.\nThen set up your \u0026ldquo;Property\u0026rdquo;, give it a name, and point it to the URL of the site you plan on tracking. Finally, click through the basic options until you land on a page with a Tracking Code which might look something like this: G-XXXXXXXXXX.\nEdit Hugo\u0026rsquo;s configuration file, e.g. config.toml, and add the tracking code.\ngoogleAnalytics = \u0026#39;G-XXXXXXXXXX\u0026#39; You should now be able to track visitors after publishing these changes. Then click on \u0026lsquo;Reports\u0026rsquo; and then on \u0026lsquo;Realtime\u0026rsquo; on https://analytics.google.com/ to track yourself visiting the page. This should work even if you run a server on your own machine and browse the site locally.\nCustomization Hugo provides endless possibilities for customization. Virtually everything can be adjusted, including spacing, font sizes, colors, text alignment, and content interaction. The basic principle is to \u0026lsquo;override\u0026rsquo; a theme\u0026rsquo;s default templates. It\u0026rsquo;s relatively easy to use a browser\u0026rsquo;s \u0026lsquo;inspection\u0026rsquo; tools, click on the ⌖ , and hover over the element that you want to adjust. This should help you understand what CSS properties are being applied to this element. You might also be able to glean a few keywords that you can later use to search for.\nModifying a Theme Most theme modifications can be done without modifying the theme\u0026rsquo;s source code repository. Hugo allows overwriting template files with your own modified version that you keep in a separate directory5.\nFor example, it\u0026rsquo;s relatively straight-forward to modify the copyright footer because most themes keep its template in a separate file. Let\u0026rsquo;s assume the footer template is kept in\nthemes/\u0026lt;THEME\u0026gt;/layouts/\u0026lt;SUBDIR\u0026gt;/footer.html Obviously, the \u0026lt;THEME\u0026gt; and \u0026lt;SUBDIR\u0026gt; directories depend on your particular theme. If you have trouble finding the right file, browse your theme\u0026rsquo;s layouts/_default directory or grep for a keyword, e.g. grep footer -R. That should give you a rough idea of where to look.\nOnce we have identified the right file we make a copy of it and place it in:\nlayouts/\u0026lt;SUBDIR\u0026gt;/footer.html You might have to create the directory structure first, e.g. mkdir -p layouts/\u0026lt;SUBDIR\u0026gt; before you copy the template with cp -iv themes/\u0026lt;THEME\u0026gt;/layouts/\u0026lt;SUBDIR\u0026gt;/footer.html layouts/\u0026lt;SUBDIR\u0026gt;/\nThis copy has precedence over the theme\u0026rsquo;s \u0026lsquo;default\u0026rsquo; templates. You can edit the copy to your heart\u0026rsquo;s content. The changes should be immediately visible (or any errors) if you\u0026rsquo;re running the server (hugo server) at the same time. Reverting back to the original theme is as easy as deleting the file.\nImages Images help your site stand out. They are added to the static/ directory or any subdirectory within. For example, after creating a subdirectory (mkdir -p static/images/), images can then be referenced in markdown.\n![Alt Description](/images/cover.jpeg) Alternatively, some themes allow adding a caption (i.e. title) by using the Go syntax.\n{{\u0026lt; figure src=\u0026#34;/images/cover.jpeg\u0026#34; title=\u0026#34;Caption text.\u0026#34; \u0026gt;}} Conclusion We\u0026rsquo;ve barely scratched the surface of what Hugo can do. Setting up a basic static site is not as easy as some commercial offers like Squarespace and Wordpress. But if you\u0026rsquo;re comfortable on the command line and using an markdown editor this setup offers you full freedom over every aspect of your site. And it\u0026rsquo;s free!\nFAQ How do I update themes? If you\u0026rsquo;ve used the git submodule add command to clone a theme repository into the themes/ folder you can preview possible updates\ngit fetch origin git status or pull updates and merge them automatically\ngit pull More info here.\nI forgot to add \u0026ndash;recurse-submodules You might not see changes appear on GitHub Pages if you forgot to add the --recurse-submodules switch when pushing the main source repository. You can rectify this by entering the submodules directory (e.g. cd public) and running git push there manually.\nLinks   Static sites can be hosted in a number of locations, such as Amazon S3, Azure, CloudFront, DreamHost, Firebase, GitHub Pages, GitLab Pages, Google Cloud Storage, Heroku, Netlify, Surge.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Creating a Blog with Hugo and Github in 10 minutes\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Avoiding Git Problems When Installing a Theme to Hugo\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Hugo: Draft, Future, and Expired Content\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n Customize a Theme\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jan-scholz.github.io/post/2022-03-05-how-to-create-this-blog/","summary":"Getting Started with Hugo Hugo is a static site generator (SSG). Simply put, an SSG prepares everything needed to display a website. In contrast, dynamically assembled websites obtain their assets only after they get accessed. An SSG thus minimizes the computational demand on the server, which allows providers, such as GitHub Pages and others1, to host your static sites for free. More importantly, SSGs emanate a philosophy of simplicity-by-design stemming from a number of limitations.","title":"How To Create This Blog"},{"content":"Data Artifacts An anti-pattern is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive 1. These anti-patterns can be identified in management approaches, software design, programming, and probably whenever people come together to achieve anything.\nData Science has its own set of anti-patterns that data scientist and their project managers should be aware of. “Proliferating Data Artifacts” refers to the behaviour of generating datasets which represent various stages of processing. The data scientists often have to wrangling the data into the right shape for analysis. This might include basic things like joining, filtering, mapping and aggregating data as well as any number of complex feature engineering techniques. There is a strong incentive to save the processed data after each processing step to avoid unnecessary re-processing when changes to the code affect only later steps.\nThe choice to save intermediate data artifacts can, however, become very costly when multiple versions of the same data exist. We all know this from trying to save word documents as _v1.doc, _v2.doc, etc. A colleague might email back some changes, but renames the document to _v2_John.doc destroying the whole idea of a well-defined genealogy of documents. God forbid anyone ever tries to save a document as _final.doc. Future versions with an ever-growing _final_final_... suffix are all but inevitable.\nUnlike text documents, datasets can easily take up gigabytes of space. Multiplied with the number of distinct processing steps and their variations this can grow rapidly to a level where the dreaded \u0026lsquo;out-of-space\u0026rsquo; warning hits the poor data scientist. According to Murphy\u0026rsquo;s law this will always happen just before a critical deadline. In any case, the data scientist often finds it hard to decide which dataset to delete, as he/she might be unsure which one was the latest or if it is still needed. As a consequence a disproportionate amount of time is spent on managing intermediate data artifacts and storage space.\n The \u0026ldquo;Proliferating Data Artifacts\u0026rdquo; anti-pattern leads to the unnecessary management of intermediate data artifacts and storage space.\n Pipelines to the Rescue But as with every anti-pattern — there is a solution! Pipelines. Pipelines manage intermediate datasets under-the-hood. A pipeline is basically a directed acyclic graph that describes the step-wise processing of the data.\nIt is easy to see that any data artifact could be recreated by applying all the processing steps (arrows) that lead to it to the preceding data. All that is needed is the input data and a well-defined pipeline.\nThe pipeline approach has several advantages:\n The user does not need to track, save, or pass on (large) data artifacts. Unnecessary re-processing of unchanged/unaffected data artifacts is avoided. A pipeline is defined in code and can be versioned. Data artifacts from any pipeline version can easily and reproducibly be re-created.  There are many more advantages that a good pipeline implementation can offer, such as parallel processing of independent parts of the pipeline, being self-contained, restart after failure, and efficient propagation of data changes.\nSo there\u0026rsquo;s really no excuse not to use existing pipeline frameworks (or implement them yourself) and delete those proliferating data artifacts! 2\n  Wikipedia: Anti-Pattern\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The original version of this text was published 2018-05-09.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jan-scholz.github.io/post/2021-11-16-data-science-anti-patterns/","summary":"Data Artifacts An anti-pattern is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive 1. These anti-patterns can be identified in management approaches, software design, programming, and probably whenever people come together to achieve anything.\nData Science has its own set of anti-patterns that data scientist and their project managers should be aware of. “Proliferating Data Artifacts” refers to the behaviour of generating datasets which represent various stages of processing.","title":"Data Science Anti-Patterns: Proliferating Data Artifacts"},{"content":"1. Serve your model quickly. The ultimate measure of success is that the insights generated by your model are useful to someone. The sooner that someone looks at the model output the sooner he/she can provide valuable feedback. I\u0026rsquo;d not be surprised if currently the vast majority of advanced analytics projects are shelved or abandoned, because the predictions cannot be integrated into business processes in a meaningful way. Or something is predicted that was already known by other means. A quickly-served model will also help you answer all your questions around performance, visualization, and production environment. As a result you\u0026rsquo;re less likely to optimize prematurely, over-deliver, and you can ensure that the model can continue to exist past the end of the project.\n2. Data Science projects are inherently iterative. Data quality can usually not be determined before modelling and model experimentation might affect data acquisition and pre-processing. Going through these iterations is often more efficient than trying to ascertain truths about data quality and model choice in advance. Many clients are worried about the quality and quantity of their data and might want to delay the start of a data science project until they\u0026rsquo;re sure that success is guaranteed. However, the most efficient way to determine data quality is by modelling.\n Data science projects are people projects.\n 3. Data Science projects are similar to software projects. They benefit from team spirit, improved communication, and a culture that encourages experimentation and learning. Clients are often concerned that they\u0026rsquo;re not getting the ‘best’ model and the ‘most accurate’ prediction. But the fact that the speed and quality of delivery could be easily improved with a few simple measures is often forgotten. In the end, data science projects are people projects. Things like a distraction-free work environment, easy access to an adequate development environment, ergonomic workplace and hardware, and easy access to data, have a bigger impact on success than a particular model choice.\n Bonus Rule: Chose technology and tooling to support all of the above.\n Three quick rules for successful Data Science projects. Interested readers might want to learn about a structured Data Science approach like CRISP-DM 1 next. 2\n  CRoss Industry Standard Process for Data Mining (CRISP-DM)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n The original version of this text was published 2018-02-08.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","permalink":"https://jan-scholz.github.io/post/2021-08-03-three-rules-of-success/","summary":"1. Serve your model quickly. The ultimate measure of success is that the insights generated by your model are useful to someone. The sooner that someone looks at the model output the sooner he/she can provide valuable feedback. I\u0026rsquo;d not be surprised if currently the vast majority of advanced analytics projects are shelved or abandoned, because the predictions cannot be integrated into business processes in a meaningful way. Or something is predicted that was already known by other means.","title":"Three Rules of Success for Data Science Projects"}]